{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 997d2b23be7a9c05a02d","webpack:///./node_modules/mixwith/mixwith.js","webpack:///./src/utils/index.js","webpack:///./src/mixins/bootstrap-element/index.js","webpack:///./src/index.js","webpack:///./src/base-component/index.js","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./src/mixins/bootstrap-element/helpers/index.js"],"names":["toHyphenCase","word","replace","toLowerCase","toCamelCase","args","toUpperCase","BootstrapElement","Mixin","name","classInstance","classProto","Object","getPrototypeOf","propName","defineProperty","configurable","get","serializeAttrValue","getAttribute","set","value","setAttribute","attributes","observedAttributes","keys","forEach","attr","attrName","defineProp","bind","hasAttribute","val","removeAttribute","superclass","BaseCustomElement","setup","beforeRender","constructor","createAttributesToProperties","oldVal","newVal","props","renderComponent","markup","getTemplate","render","afterRender","mix","HTMLElement","with","envCachesTemplates","t","s","templates","Map","svgTemplates","html","strings","values","litTag","svg","isSvg","key","join","template","undefined","Template","TemplateResult","result","container","partCallback","defaultPartCallback","instance","__templateInstance","_partCallback","update","TemplateInstance","fragment","_clone","child","lastChild","removeChild","appendChild","attributeMarker","Math","random","textRegex","hasTagsRegex","textMarkerContent","textMarker","attrOrTextRegex","RegExp","TemplatePart","type","index","rawName","parts","element","document","createElement","innerHTML","_getHtml","walker","createTreeWalker","content","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","i","length","attribute","item","attributeStrings","split","attributeString","rawNameString","substring","match","push","nodeValue","parent","parentNode","lastIndex","textContent","insertBefore","createTextNode","previousSibling","nextSibling","trim","Text","n","l","a","isTextBinding","getValue","part","__litDirective","directive","f","AttributePart","size","startIndex","text","v","Array","isArray","Symbol","iterator","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","Node","_setNode","then","_setPromise","clear","_insert","TEXT_NODE","itemParts","itemPart","itemStart","previousPart","setValue","lastPart","templatePart","Error","_parts","valueIndex","importNode","svgElement","firstChild","nodes","childNodes","isObjOrArray","test","hasBooleanAttr","updatedValue","JSON","parse","e","console","error"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;gGC7DA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,E;;;;;;;;AC/FD;AAAA;;;;;AAKO,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC/B,SAAOA,KAAKC,OAAL,CAAa,iBAAb,EAAgC,OAAhC,EAAyCC,WAAzC,EAAP;AACH;;AAED;;;;;AAKO,SAASC,WAAT,CAAqBH,IAArB,EAA2B;AAC9B,SAAOA,KAAKE,WAAL,GAAmBD,OAAnB,CAA2B,eAA3B,EAA4C;AAAA,sCAAIG,IAAJ;AAAIA,UAAJ;AAAA;;AAAA,WAAaA,KAAK,CAAL,EAAQC,WAAR,EAAb;AAAA,GAA5C,CAAP;AACH,C;;;;;;;;;;;;;;;;;;;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","file":"wc-base-component.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcBaseComponent\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcBaseComponent\"] = factory();\n\telse\n\t\troot[\"wcBaseComponent\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 997d2b23be7a9c05a02d","'use strict';\n\n(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.mixwith = mod.exports;\n  }\n})(this, function (exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  const _cachedApplicationRef = exports._cachedApplicationRef = Symbol('_cachedApplicationRef');\n\n  const _mixinRef = exports._mixinRef = Symbol('_mixinRef');\n\n  const _originalMixin = exports._originalMixin = Symbol('_originalMixin');\n\n  const wrap = exports.wrap = (mixin, wrapper) => {\n    Object.setPrototypeOf(wrapper, mixin);\n    if (!mixin[_originalMixin]) {\n      mixin[_originalMixin] = mixin;\n    }\n    return wrapper;\n  };\n\n  const Cached = exports.Cached = mixin => wrap(mixin, superclass => {\n    // Get or create a symbol used to look up a previous application of mixin\n    // to the class. This symbol is unique per mixin definition, so a class will have N\n    // applicationRefs if it has had N mixins applied to it. A mixin will have\n    // exactly one _cachedApplicationRef used to store its applications.\n    let applicationRef = mixin[_cachedApplicationRef];\n    if (!applicationRef) {\n      applicationRef = mixin[_cachedApplicationRef] = Symbol(mixin.name);\n    }\n    // Look up an existing application of `mixin` to `c`, return it if found.\n    if (superclass.hasOwnProperty(applicationRef)) {\n      return superclass[applicationRef];\n    }\n    // Apply the mixin\n    let application = mixin(superclass);\n    // Cache the mixin application on the superclass\n    superclass[applicationRef] = application;\n    return application;\n  });\n\n  const HasInstance = exports.HasInstance = mixin => {\n    if (Symbol.hasInstance && !mixin.hasOwnProperty(Symbol.hasInstance)) {\n      Object.defineProperty(mixin, Symbol.hasInstance, {\n        value: function (o) {\n          const originalMixin = this[_originalMixin];\n          while (o != null) {\n            if (o.hasOwnProperty(_mixinRef) && o[_mixinRef] === originalMixin) {\n              return true;\n            }\n            o = Object.getPrototypeOf(o);\n          }\n          return false;\n        }\n      });\n    }\n    return mixin;\n  };\n\n  const BareMixin = exports.BareMixin = mixin => wrap(mixin, superclass => {\n    // Apply the mixin\n    let application = mixin(superclass);\n\n    // Attach a reference from mixin applition to wrapped mixin for RTTI\n    // mixin[@@hasInstance] should use this.\n    application.prototype[_mixinRef] = mixin[_originalMixin];\n    return application;\n  });\n\n  const Mixin = exports.Mixin = mixin => Cached(HasInstance(BareMixin(mixin)));\n\n  const mix = exports.mix = superClass => new MixinBuilder(superClass);\n\n  class MixinBuilder {\n    constructor(superclass) {\n      this.superclass = superclass;\n    }\n\n    with() {\n      return Array.from(arguments).reduce((c, m) => m(c), this.superclass);\n    }\n\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mixwith/mixwith.js\n// module id = 0\n// module chunks = 0","/**\n * Converts string camelcase to hyphennated\n * @param {string} word data that passed to the function\n * @return {string} word converted string\n */\nexport function toHyphenCase(word) {\n    return word.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n/**\n * Converts string hyphennated to camelcase\n * @param {string} word data that passed to the function\n * @return {string} word converted string\n */\nexport function toCamelCase(word) {\n    return word.toLowerCase().replace(/[-_]+([a-z])/g, (...args) => args[1].toUpperCase());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/index.js","import { Mixin } from 'mixwith';\nimport { toCamelCase } from '../../utils';\nimport serializeAttrValue from './helpers';\n\n/**\n * This module create property instance and get/set for all attributes and observedAttributes\n */\nconst BootstrapElement = Mixin(superclass => class extends superclass {\n    /**\n     * This is re-usable static method, which sets property on the instance prototype based on the given attribute name\n     * @param {string} name attribute name\n     */\n    defineProp(name) {\n        if (!name) return;\n\n        const classInstance = this;\n        const classProto    = Object.getPrototypeOf(classInstance);\n        const propName      = toCamelCase(name);\n\n        if (propName in classProto) return;\n\n        Object.defineProperty(classProto, propName, {\n            configurable: true,\n            get() {\n                return serializeAttrValue(name, this.getAttribute(name));\n            },\n            set(value) {\n                this.setAttribute(name, value);\n            }\n        });\n    }\n\n    /**\n     * This loops through all the given attributes, observedAttributes and send it to `defineProp()`\n     * @param {array} attributes list of attributes added to the component\n     * @param {array} observedAttributes list of observed attributes\n     */\n    createAttributesToProperties(attributes, observedAttributes) {\n        // attributes to properties\n        Object.keys(attributes).forEach((attr) => {\n            const attrName = attributes[attr].name;\n            this.defineProp(attrName);\n        });\n\n        // observedAttributes to properties\n        observedAttributes.forEach(this.defineProp.bind(this));\n    }\n\n    /**\n     * has attribute\n     * @param {string} attribute name\n     */\n    has(attr) {\n        return this.hasAttribute(attr);\n    }\n\n    /**\n     * set attribute value\n     * @param {string} attribute name\n     */\n    get(attr) {\n        return this.getAttribute(attr);\n    }\n\n    /**\n     * set attribute value\n     * @param {string} attribute name\n     * @param {string} new/changed value for the attribute\n     */\n    set(attr, val) {\n        return this.setAttribute(attr, val);\n    }\n\n    /**\n     * remove attribute\n     * @param {string} attribute name\n     */\n    remove(attr) {\n        return this.removeAttribute(attr);\n    }\n});\n\nexport default BootstrapElement;\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/bootstrap-element/index.js","export { default as BaseCustomElement } from './base-component';\nexport { default as BootstrapElement } from './mixins/bootstrap-element';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { render } from 'lit-html';\nimport { mix } from 'mixwith';\nimport { toCamelCase } from '../utils';\nimport BootstrapElement from '../mixins/bootstrap-element';\n\n/**\n * custom element base class for eap elements library, which extends from HTMLElement class\n */\nclass BaseCustomElement extends mix(HTMLElement).with(BootstrapElement) {\n    connectedCallback() {\n        this.setup();\n        this.beforeRender();\n\n        this.set('enhanced', '');\n    }\n\n    setup() {\n        const attributes         = this.attributes || {};\n        const observedAttributes = this.constructor.observedAttributes || [];\n        this.createAttributesToProperties(attributes, observedAttributes);\n    }\n\n    attributeChangedCallback(attrName, oldVal, newVal) {\n        if (!oldVal || oldVal === newVal) return;\n        const propName = toCamelCase(attrName);\n        this[propName] = newVal;\n\n        this.props = {\n            ...this.props,\n            [propName]: newVal\n        };\n\n        this.renderComponent(this.props);\n    }\n\n    beforeRender() {\n        this.renderComponent();\n    }\n\n    renderComponent() {\n        const markup = this.constructor.getTemplate(this.props);\n        if (!markup) return;\n\n        render(markup, this);\n\n        this.afterRender();\n    }\n\n    afterRender() {}\n}\n\nexport default BaseCustomElement;\n\n\n\n// WEBPACK FOOTER //\n// ./src/base-component/index.js","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * TypeScript has a problem with precompiling templates literals\n * https://github.com/Microsoft/TypeScript/issues/17956\n *\n * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and\n * TypeScript to verify correctness.\n */\nconst envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nconst templates = new Map();\nconst svgTemplates = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => litTag(strings, values, templates, false);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);\nfunction litTag(strings, values, templates, isSvg) {\n    const key = envCachesTemplates ?\n        strings :\n        strings.join('{{--uniqueness-workaround--}}');\n    let template = templates.get(key);\n    if (template === undefined) {\n        template = new Template(strings, isSvg);\n        templates.set(key, template);\n    }\n    return new TemplateResult(template, values);\n}\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(template, values) {\n        this.template = template;\n        this.values = values;\n    }\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n */\nexport function render(result, container, partCallback = defaultPartCallback) {\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === result.template &&\n        instance._partCallback === partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(result.template, partCallback);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    let child;\n    while ((child = container.lastChild)) {\n        container.removeChild(child);\n    }\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid\n * https://github.com/PolymerLabs/lit-html/issues/62\n */\nconst attributeMarker = `{{lit-${Math.random()}}}`;\n/**\n * Regex to scan the string preceding an expression to see if we're in a text\n * context, and not an attribute context.\n *\n * This works by seeing if we have a `>` not followed by a `<`. If there is a\n * `<` closer to the end of the strings, then we're inside a tag.\n */\nconst textRegex = />[^<]*$/;\nconst hasTagsRegex = /[^<]*/;\nconst textMarkerContent = '_-lit-html-_';\nconst textMarker = `<!--${textMarkerContent}-->`;\nconst attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport class Template {\n    constructor(strings, svg = false) {\n        this.parts = [];\n        this.svg = svg;\n        this.element = document.createElement('template');\n        this.element.innerHTML = this._getHtml(strings, svg);\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                for (let i = 0; i < attributes.length; i++) {\n                    const attribute = attributes.item(i);\n                    const attributeStrings = attribute.value.split(attrOrTextRegex);\n                    if (attributeStrings.length > 1) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute attribute\n                        const attributeString = strings[partIndex];\n                        // Trim the trailing literal value if this is an interpolation\n                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);\n                        // Find the attribute name\n                        const rawName = rawNameString.match(/((?:\\w|[.\\-_$])+)=[\"']?$/)[1];\n                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));\n                        node.removeAttribute(attribute.name);\n                        partIndex += attributeStrings.length - 1;\n                        i--;\n                    }\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                const strings = nodeValue.split(attributeMarker);\n                if (strings.length > 1) {\n                    const parent = node.parentNode;\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // We keep this current node, but reset its content to the last\n                    // literal part. We insert new literal nodes before this so that the\n                    // tree walker keeps its position correctly.\n                    node.textContent = strings[lastIndex];\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore(document.createTextNode(strings[i]), node);\n                        this.parts.push(new TemplatePart('node', index++));\n                    }\n                }\n                else {\n                    // Strip whitespace-only nodes, only between elements, or at the\n                    // beginning or end of elements.\n                    const previousSibling = node.previousSibling;\n                    const nextSibling = node.nextSibling;\n                    if ((previousSibling === null ||\n                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        (nextSibling === null ||\n                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&\n                        nodeValue.trim() === '') {\n                        nodesToRemove.push(node);\n                        currentNode = previousNode;\n                        index--;\n                    }\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === textMarkerContent) {\n                const parent = node.parentNode;\n                // If we don't have a previous node add a marker node.\n                // If the previousSibling is removed, because it's another part\n                // placholder, or empty text, add a marker node.\n                if (node.previousSibling === null ||\n                    node.previousSibling !== previousNode) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a next node add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(new Text(), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    _getHtml(strings, svg) {\n        const l = strings.length;\n        const a = [];\n        let isTextBinding = false;\n        for (let i = 0; i < l - 1; i++) {\n            const s = strings[i];\n            a.push(s);\n            // We're in a text position if the previous string matches the\n            // textRegex. If it doesn't and the previous string has no tags, then\n            // we use the previous text position state.\n            isTextBinding = s.match(textRegex) !== null ||\n                (s.match(hasTagsRegex) !== null && isTextBinding);\n            a.push(isTextBinding ? textMarker : attributeMarker);\n        }\n        a.push(strings[l - 1]);\n        const html = a.join('');\n        return svg ? `<svg>${html}</svg>` : html;\n    }\n}\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (value != null && value.__litDirective === true) {\n        value = value(part);\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n    }\n    setValue(values, startIndex) {\n        const strings = this.strings;\n        let text = '';\n        for (let i = 0; i < strings.length; i++) {\n            text += strings[i];\n            if (i < strings.length - 1) {\n                const v = getValue(this, values[startIndex + i]);\n                if (v &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        // TODO: we need to recursively call getValue into iterables...\n                        text += t;\n                    }\n                }\n                else {\n                    text += v;\n                }\n            }\n        }\n        this.element.setAttribute(this.name, text);\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === null ||\n            !(typeof value === 'object' || typeof value === 'function')) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value === undefined ? '' : value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        let instance;\n        if (this._previousValue &&\n            this._previousValue.template === value.template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance =\n                new TemplateInstance(value.template, this.instance._partCallback);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n        this._previousValue = value;\n    }\n    clear(startNode = this.startNode) {\n        let node;\n        while ((node = startNode.nextSibling) !== this.endNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback = defaultPartCallback) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        if (this.template.parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);\n            const parts = this.template.parts;\n            let index = 0;\n            let partIndex = 0;\n            let templatePart = parts[0];\n            let node = walker.nextNode();\n            while (node != null && partIndex < parts.length) {\n                if (index === templatePart.index) {\n                    this._parts.push(this._partCallback(this, templatePart, node));\n                    templatePart = parts[++partIndex];\n                }\n                else {\n                    index++;\n                    node = walker.nextNode();\n                }\n            }\n        }\n        if (this.template.svg) {\n            const svgElement = fragment.firstChild;\n            fragment.removeChild(svgElement);\n            const nodes = svgElement.childNodes;\n            for (let i = 0; i < nodes.length; i++) {\n                fragment.appendChild(nodes.item(i));\n            }\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=lit-html.js.map\n\n\n// WEBPACK FOOTER //\n// ./node_modules/lit-html/lit-html.js","/**\n * serialize attribute value from string to number/object/boolean/null or string\n * this also checks if the given attribute is a boolean attribute(named as `has-*`) without value, then returns as boolean\n * @param {string} attrName key/name of the attribute\n * @param {string} value of the attribute that needs to be serialize\n * @return {any} based on the type of the given value, it will be parsed and sent as that type\n */\nfunction serializeAttrValue(attrName, value) {\n    const isObjOrArray = (/^[{|[]/g).test(value);\n    const hasBooleanAttr = (/^has-/g).test(attrName);\n    let updatedValue;\n\n    // parse attributue value\n    try {\n        updatedValue = JSON.parse(value);\n    } catch (e) {\n        updatedValue = value;\n\n        if (isObjOrArray) {\n            updatedValue = null;\n            console.error(`Warning: Failed serializing attribute(${attrName}) value as JSON: ${value}`);\n        }\n    }\n\n    // check for has-* attributes\n    if (hasBooleanAttr) {\n        updatedValue = hasBooleanAttr;\n    }\n\n    return updatedValue;\n}\n\nexport default serializeAttrValue;\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixins/bootstrap-element/helpers/index.js"],"sourceRoot":""}